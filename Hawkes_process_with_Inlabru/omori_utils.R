library(ggplot2)
library(viridis)
library(inlabru)
library(INLA)
library(dplyr)
library(data.table)
library(metR)
library(matrixStats)
library(parallel)

# function to calculate the value of the Omori's law at given time

# input : tt --> time at which evaluate the function
#         c.p, pm1 --> parameters of Omori's law (pm1 correspond to p.p - 1)
#         Ht --> observed time poits
#         ll0 --> values for the approximation to ensure stability

# output : numeric - value of the Omori's law h(tt - Ht, c, p)
# notes : only one of parameters can be a vector, Ht has to be sorted (increas.) if 
#         a vector

trig.T3 <- function(tt, c.p, pm1, Ht, ll0 = -600){
  # compute only for positive time differeces
  diffs <- tt - Ht
  idx.p <- tt - Ht > 0
  logtrig <- log(pm1) + (pm1)*log(c.p) - (pm1 + 1)*log(diffs[idx.p] + c.p)
  
  
  # approximating for large negative logtrig
  trig = logtrig
  idx <- logtrig < ll0 
  trig[idx] <- exp(ll0)*(1 - (-logtrig[idx] + ll0))
  trig[!idx] <- exp(logtrig[!idx])
  
  toreturn <- rep(0, length(diffs))
  toreturn[idx.p] <- trig
  return(toreturn)
}

# function to calculate the integral of the time-triggering function
# between Ht and Tlim. It can be seen as the probability that a point generated by Ht
#  is smaller than Tlim
 
# input : Tlim --> Extreme of the interval of time on which calculate the integral
#         c.p , p.p --> parameters of the Omori's law (c.p > 0 , p,p > 1)
#         Ht --> observed time points 

# output : numeric - The integral of the Omori's law 
# notes : reliable only if AT MOST one input is a parameter

I.h <- function(Tlim, c.p, p.p, Ht){
  1 - (c.p^(p.p-1))*((Tlim - Ht + c.p)^(1 - p.p))
}

# stable versio of I.h, the only difference is that takes as input 
# pm1 instead of p.p, where pm1 = p.p - 1
#   values vv0 and vv1 are the extremes behind which the approximation kicks in
# - same output

I.h2 <- function(Tt, c.p, pm1, Ht, vv0 = -1e-13, vv1 = -15){
  vv <- (pm1)*log(c.p) + (-pm1)*log(Tt - Ht + c.p)
  v2 <- vv
  
  if(sum(vv > vv0) > 0){
    if(sum(vv < vv1) > 0){
      idx.small <- vv > vv0
      idx.larg.neg <- vv < vv1
      idx.ok <- !(idx.small | idx.larg.neg)
      # we use the approx exp(x) = 1 + x for small x
      v2[idx.small] <- -v2[idx.small]
      # we use the approx exp(x) = exp(x0)(1 - (x - x0))
      v2[idx.larg.neg] <- 1 - (exp(vv1) - (v2[idx.larg.neg] - vv1)*exp(vv1))
      # we use correct expression for the others
      v2[idx.ok] <- 1 - exp(v2[idx.ok])
      v2
    }
    else{
      idx.small <- vv > vv0
      idx.ok <- !idx.small
      # we use the approx exp(x) = 1 + x for small x
      v2[idx.small] <- -v2[idx.small]
      # we use correct expression for the others
      v2[idx.ok] <- 1 - exp(v2[idx.ok])
      v2
    }
    
  }
  else{
    if(sum(vv < vv1) > 0){
      idx.larg.neg <- vv < vv1
      idx.ok <- !idx.larg.neg
      # we use the approx exp(x) = exp(x0)(1 - (x - x0))
      v2[idx.larg.neg] <- 1 - (exp(vv1) - (v2[idx.larg.neg] - vv1)*exp(vv1))
      # we use correct expression for the others
      v2[idx.ok] <- 1 - exp(v2[idx.ok]) 
      v2
    }
    else{
      1 - exp(v2)
    }
  }
}

# function that computes the inverse with respect to Tlim of the I.h, meaning that 
# if I.h(Tlim,...) = u then Inv.h.cdf(u,...) = Tlim
# input : u --> value of the integral 
#         c.p, p.p --> parameters of Omori's law
#         Ht --> observed time points
# output : Tlim 
# notes : reliable only if AT MOST one input is a vector

Inv.h.cdf <- function(u, c.p, p.p, Ht){
  c.p*((1 - u)^(1/(1 - p.p))) + Ht - c.p 
}

# function to sample n points smaller as generated by Ht following a distrib.
#   given by Omori's law (only points smaller than Tlim are retained).
#   we use inverse sampling technique 

# input: n.ev --> number of points to sample from Omori's law
#        c.p ,p.p --> parameters of Omori's law
#        Ht --> observation "generating" the sample
#        Tlim --> Time limit to filter the sample

# output: numeric - vector of values between (Ht, Tlim) distribuited accordingly to 
#                   Omori's law with parameters c.p, p.p

sample.omori <- function(n.ev, c.p, p.p, Ht, Tlim){
  if(n.ev == 0){return('no samples')}
  u <- runif(n.ev)
  t.sample <- Inv.h.cdf(u, c.p, p.p, Ht)
  if(all(t.sample > Tlim)){return('no samples')}
  sort(t.sample[t.sample < Tlim])
}


# function to sample from hawkes temporal process (time triggering given by Omori's law)
#   between 0 and Tlim

# input : params --> vector of parameters of the hawkes process (mu, K, c, p)
#         Tlim --> end of time interval
#         n.core --> number of cores to be used

# output : data.frame with 2 columns :
#                     1) ts = sampled observations (sorted)
#                     2) gen = generation of the event (0 = background,
#                                                       1 = gen by bckg,
#                                                       2 = gen by 1,
#                                                       ...)

# notes: we are assuming no observations before 0 and no known points in (0,T)

sample.hawkes <- function(params, Tlim, n.core = 5){
  mu.p <- params[1]
  k.p <- params[2]
  c.p <- params[3]
  p.p <- params[4]
  
  # extract number of backgroud events
  n.backg <- rpois(1, lambda = mu.p*Tlim)
  print(c(n.backg, 0))
  # extract times homogeneously
  backg <- runif(n.backg, min = 0, max = Tlim)
  Past.Gens <- list(data.frame(ts = backg,
                               gen = 0))
  flag = T
  gen.idx = 1
  while(flag){
    # take previous generation
    past.ts <- Past.Gens[[gen.idx]]$ts
    n.past.ts <- length(past.ts)
    # for each of them sample the number of offsprings
    n.off <- rpois(n.past.ts, lambda = k.p)
    # exit condition if none of the event in the previous generation has
    # offsprings
    if(all(n.off == 0)){
      Gens.df <- bind_rows(Past.Gens)
      Gens.df <- Gens.df[order(Gens.df$ts),]
      return(Gens.df)
    }
    # select only times which has generated events
    past.ts <- past.ts[n.off > 0]
    n.off <- n.off[n.off > 0]
    
    # generate offsprings for each past event
    offsprings.list <- mclapply(1:length(past.ts), function(x)
      data.frame(ts = sample.omori(n.off[x], c.p, p.p, past.ts[x], Tlim),
                 gen = gen.idx), mc.cores = n.core)
    offsprings.df <- rbindlist(offsprings.list)
    
    offsprings.df <-
      offsprings.df %>%
      filter(ts != 'no samples') %>%
      mutate(ts = as.numeric(ts))
    
    print(c(nrow(offsprings.df), gen.idx))
    # update gen.idx
    gen.idx <- gen.idx + 1
    Past.Gens[[gen.idx]] <- offsprings.df
  }
}


# function to compute the log-intesity of the Hawkes process with Omori's temporal 
#  triggering for a single time point.

# input : ts --> time at which evaluate the log-intesity (single value)
#         params --> vector of parameters using pm1 = p - 1
#         Ht --> observed time points (has to be a numeric and sorted)

# output : numeric (single value) value of the log-intesity

# notes : In params we use pm1 = p - 1, ts has to be a single value

log.lambda.s <- function(ts, params, Ht){
  mu.p <- params[1]
  k.p <- params[2]
  c.p <- params[3]
  pm1 <- params[4]
  # triggers from each past event
  triggers <- sum(trig.T3(ts, c.p, pm1, Ht))
  
  # return
  logSumExp(c(log(mu.p), log(k.p) + log(abs(triggers))))
  # unstable
  #print(log(mu.p + k.p*triggers))
  
}


# function to compute the log-intesity of the Hawkes process with Omori's temporal 
#  triggering for a vector of values of t

# input : ts.v --> vector of times at which evaluate the log-intesity 
#         params --> vector of parameters using pm1 = p - 1
#         Ht --> observed time points (has to be a numeric and sorted)

# output : numeric (vector) value of the log-intesity evaluated at ts.v

log.lambda <- function(ts.v, params, Ht){
  sapply(ts.v, function(t) log.lambda.s(t, params, Ht))
}




# function to produce a ggplot2 plot containing:
#       1) the histogram of the observed times 
#       2) the approximated expected number of points in each bin 
#          using an Hawkes process model with Omori's triggering with potentially
#          multiple parameters combinations
# OR 
#       1) the cumulative number of points (observed and expected)

# input : params.list --> list of parametrization with which calculate the expected
#                         number of points (each element has to be a combination of
#                         (mu, k, c, p - 1))
#         Ht.df --> data.frame with the observed points, the column containing the
#                   points has to be called "ts"
#         Tlim --> extend of the observations
#         by.s --> binsize for the histogram and used to calculate the cumulative 
#                  values
#         params.names --> vector of char containing the names of the differet 
#                          parametrizations contained in params.list (if NULL 
#                          1:length(params.list) is used)
#         cumulative --> if TRUE cumulative plot if FALSE histogram

# output : ggplot obj

# notes : the expected number of points in each bin is approximated as lambda*delta
#         where lambda : value of the intensity at the midpoint
#               delta : binwidth


toplot.hist.lambda <- function(params.list, Ht.df, Tlim, by.s = 0.05,
                               params.names = NULL, cumulative = FALSE){
  
  
  # names of different parametrizations if not provided
  if(is.null(params.names) & is.list(params.list)){
    params.names <- 1:length(params.list)
  }
  # breaks and midpoits of the histogram
  brks <- seq(0,Tlim,by = by.s)
  mids <- brks[-length(brks)] + by.s/2
  
  # if cumulative = TRUE we have to produce a cumulative plot
  if(cumulative){
    # create the histogram to obtain counts
    hh <- hist(Ht.df$ts, breaks = brks, plot = FALSE)
    # initialize df for plotting
    counts.df <- data.frame(ts = hh$mids,
                            counts = cumsum(hh$counts),
                            params = 'observed')
    # if only one parametrization
    if(is.numeric(params.list)){
      # add expected counts to the df
      counts.df <- rbind(counts.df,
                         data.frame(ts = mids,
                                    counts = cumsum(exp(log.lambda(mids, params.list,
                                                                   Ht.df$ts))*by.s),
                                    params = 'model'))
      # plot
      return(ggplot(counts.df, aes(x = ts, y = counts, color = params)) + 
               geom_line())
    }
    # if we have multiple parametrizations
    if(is.list(params.list)){
      # create df for each of them
      counts.list <- lapply(1:length(params.list), function(idx)
        data.frame(ts = mids,
                   counts = cumsum(exp(log.lambda(mids, params.list[[idx]],
                                                  Ht.df$ts))*by.s),
                   params = paste0('model-',params.names[[idx]])))
      # combine dfs
      counts.df.app <- bind_rows(counts.list)
      
      counts.df <- rbind(counts.df,
                         counts.df.app)
      # plot
      return(ggplot(counts.df, aes(x = ts, y = counts, color = params)) + 
               geom_line())
    }
    
    
  }
  
  # IF we are here then cumulative was FALSE
  # if only one parametrization
  if(is.numeric(params.list)){
    # initialize df
    ll.df <- data.frame(ts = mids,
                        lambda = exp(log.lambda(mids, params.list, Ht.df$ts))*by.s)
    # plot
    return(ggplot(Ht.df, aes(x = ts)) + 
             geom_histogram(breaks = brks) + 
             geom_line(data = ll.df, aes(x = ts, y = lambda),
                       color = 'dodgerblue2'))
  }
  # if multiple parametrizations
  if(is.list(params.list)){
    # create df for each parametrization
    ll.list <- lapply(1:length(params.list), function(idx) 
      data.frame(ts = mids,
                 lambda = exp(log.lambda(mids, params.list[[idx]], Ht.df$ts))*by.s,
                 params = params.names[idx]))
    # merge df
    ll.df <- bind_rows(ll.list)
    # plot
    return(ggplot(Ht.df, aes(x = ts)) + 
             geom_histogram(breaks = brks) + 
             geom_line(data = ll.df, aes(x = ts, y = lambda, 
                                         color = as.factor(params))))
    
  }
  
}


# function to calculate the expected number of points in (0,T) given that Ht has
#   been observed considering an Hawkes process process with Omori's triggering

# input : params --> vector of parameters of the model (mu, k, c, p-1)
#         Tlim --> limit of the time interval
#         Ht --> observed time points (as sorted vector)

# output : numeric - value of the integral of lambda(t)|Ht in (0,T)  

exp.nev <- function(params, Tlim, Ht){
  params[1]*Tlim + params[2]*sum(I.h2(Tlim, params[3], params[4]+1, Ht))
}

# function to calculate the log-likelihood of an Hawkes process with Omori's trigg.

# input : params --> vector of parameters of the model (mu, k, c, p-1)
#         Tlim --> limit of the time interval
#         Ht --> observed time points (as sorted vector)

# output : numeric - value of the log-likelihood

hawkes.loglik <- function(params, Tlim, Ht){
  integ <- exp.nev(params, Tlim, Ht)
  summation <- sum(log.lambda(Ht,params,Ht))
  summation - integ
}

# same functions of above but returns -log.lik, to be used for optimization
hawkes.loglik.to.optim <- function(params, Tlim, Ht){
  params <- exp(params)
  -hawkes.loglik(params, Tlim, Ht)
}

# Derivative of the Hawkes process intesity with respect to K

# input : t --> time at which the derivative has to be evaluated
#         theta2 --> log-value of the parameter with respect which we are deriving
#         c.p, pm1 --> parameters of Omori's law (pm1 = p - 1)
#         Ht --> history of the process

# output : numeric - value of derivative

# notes: if t and Ht both single values and Ht > t then it returns zero.

theta2.der <- function(t, theta2, c.p, pm1, Ht){
  if(sum(Ht < t) > 0){
    Ht.f <- Ht[Ht < t]
    vv <- exp(theta2)*trig.T3(t, c.p, pm1, Ht.f)
    return(sum(vv))  
  }
  else{
    return(0)
  }
}

# Derivative of the Hawkes process intesity with respect to c

# input : t --> time at which the derivative has to be evaluated
#         theta3 --> log-value of the parameter with respect which we are deriving
#         K.p, pm1 --> parameters of the intensity (pm1 = p - 1)
#         Ht --> history of the process

# output : numeric - value of derivative

# notes: if t and Ht both single values and Ht > t then it returns zero.

theta3.der <- function(t, K.p, theta3, pm1, Ht){
  if(sum(Ht < t) > 0){
    Ht.f <- Ht[Ht < t]
    vv <- K.p*pm1*exp(pm1*theta3)*((t - Ht.f + exp(theta3))^(-(pm1  + 2)))*(pm1*(t-Ht.f) - exp(theta3))
    return(sum(vv))  
  }
  else{
    return(0)
  }
}

# Derivative of the Hawkes process intesity with respect to p

# input : t --> time at which the derivative has to be evaluated
#         theta4 --> log-value of the parameter with respect which we are deriving
#                     here theta4 = log(p-1)
#         K.p, c.p --> parameters of the intensity 
#         Ht --> history of the process

# output : numeric - value of derivative

# notes: if t and Ht both single values and Ht > t then it returns zero.

theta4.der <- function(t, K.p, c.p, theta4, Ht){
  
  if(sum(Ht < t) > 0){
    Ht.f <- Ht[Ht < t]
    dd <- t - Ht.f + c.p
    vv1 <- 1 + exp(theta4)*(log(c.p) - log(dd))
    
    vv <- K.p*exp(theta4)*(c.p^(exp(theta4)))*((t - Ht.f +
                                                  c.p)^(-exp(theta4)-1))*vv1
    
    return(sum(vv))  
  }
  else{
    return(0)
  }
}


# function to approximate linearly (in the parameter) with respect a given point
# the log-intesity of an Hawkes process model with Omori's triggering

# input : t --> time at which the derivative has to be evaluated (single)
#         thetas --> logarithm of the parameters value 
#                     (log(mu), log(k), log(c), log(p-1))
#         Ht --> history of the process
#         theta0 --> value of the parameters around which perform the approximation

# output : numeric - approximated log-intesity

# notes: t has to be a single value.


lin.log.lambda <- function(t, thetas, Ht, theta0){
  coeff <- 1/exp(log.lambda(t, exp(theta0), Ht))
  
  deriv.v <- c(exp(theta0[1]), 
               theta2.der(t, theta0[2], exp(theta0[3]), 
                          exp(theta0[4]), Ht),
               theta3.der(t, exp(theta0[2]), theta0[3],
                          exp(theta0[4]), Ht),
               theta4.der(t, exp(theta0[2]), exp(theta0[3]),
                          theta0[4], Ht))
  
  vv <- (thetas - theta0) %*% deriv.v
  log.lambda(t, exp(theta0), Ht) + as.numeric(vv)*coeff
}

# linearized log-intesity for multiple times.
lin.log.lambda2 <- function(tv, thetas, Ht, theta0){
  sapply(tv, function(x) lin.log.lambda(x, thetas, Ht, theta0))
}

# function to approximate numerically the integral of the exponential of the 
#   linearized log.intesity between 0 and Tlim

# input : params --> vector of paramters (mu, k, c, p-1)
#         Tlim --> value defining the integration interval
#         Ht --> observed time points (sorted vector)
#         theta0 --> value around which perform the approximation 
#                    (log(mu), log(k), log(c), log(p-1))
#         by.s --> binwidth for the numerical approximation of the integral

# output : numeric value of the approximated integral (single value)

# notes : the approximation is performed splittig (0,Tlim) in equal bins of width 
#         by.s, the integrand is considered constant in each bin.

exp.nev.lin <- function(params, Tlim, Ht, theta0, by.s = 0.01){
  ips <- ipoints(inla.mesh.1d(loc = seq(0, Tlim, by = by.s)))
  sum(exp(lin.log.lambda2(ips$x, log(params), Ht, theta0))*ips$weight)
}


# function to approximate the log-likelihood of an Hawkes process model with Omori's 
#   triggering

# input : params --> vector of paramters (mu, k, c, p-1)
#         Tlim --> value defining the integration interval
#         Ht --> observed time points (sorted vector)
#         theta0 --> value around which perform the approximation 
#                    (log(mu), log(k), log(c), log(p-1))
#         by.s --> binwidth for the numerical approximation of the integral

# output : numeric value of the approximated log-likelihood (single value)

# notes : the approximation is considering the linearized log intesity to approximate 
#         the summation and the numerical approximation of the integral of the 
#         exponential of the linearized log-intensity to approximate the integral

hawkes.loglik.lin <- function(params, Tlim, Ht, theta0, by.s = 0.01){
  integ <- exp.nev.lin(params, Tlim, Ht, theta0, by.s)
  ll <- lin.log.lambda2(Ht, log(params), Ht, theta0)
  
  - integ + sum(ll)
}


# function to plot the comparison between approximated and not approximated 
#   Hawkes process log-likelihood decomposing it in summation and integral
#   This is done considering only one parameter as varying and the other fixed

# input : par.values --> values of the parameter that we want to vary
#         par.idx --> index of the parameter that we want to vary 
#                     (1 = mu, 2 = k, 3 = c, 4 = p-1)
#         ML.est --> value of the parameters that are not varying
#         Tlim --> extreme of the interval containing the observations
#         Ht --> observed time points (sorted vector)
#         by.s --> binwidth for approximating the integral
#         ll.ylim --> ylim of the loglik plot
#         ss.ylim --> ylim of the summation plot
#         ee.ylim --> ylim of the expected value plot

# output : 1 ggplot obj containing three plots each of which compares the 
#          approximated model with the analytically calculated one:
#                       1) plot of log-likelihood
#                       2) plot of summation component
#                       3) plot of expected value

toplot.loglik.dec <- function(par.values, par.idx, ML.est, Tlim, Ht, 
                              by.s = 0.01, par.name = 'par',
                              ll.ylim = c(400, 700),
                              ss.ylim = c(700,1000), 
                              ee.ylim = c(100,350),
                              total.ylim = c(0,1000)){
  
  if(par.idx == 1){par.matrix <- cbind(par.values, ML.est[2], 
                                       ML.est[3], ML.est[4])}
  if(par.idx == 2){par.matrix <- cbind(ML.est[1], par.values, 
                                       ML.est[3], ML.est[4])}
  if(par.idx == 3){par.matrix <- cbind(ML.est[1], ML.est[2], 
                                       par.values, ML.est[4])}
  if(par.idx == 4){par.matrix <- cbind(ML.est[1], ML.est[2], 
                                       ML.est[3], par.values)}
  
  ll <- sapply(1:nrow(par.matrix), function(x)
    hawkes.loglik(par.matrix[x,], Tlim, Ht))
  
  ll.approx <- sapply(1:nrow(par.matrix), function(x) 
    hawkes.loglik.lin(par.matrix[x,], Tlim, Ht, log(ML.est), by.s = by.s))
  
  sum.true <- sapply(1:nrow(par.matrix), function(x) 
    sum(log.lambda(ht$ts, par.matrix[x,], Ht)))
  
  sum.approx <- sapply(1:nrow(par.matrix), function(x) 
    sum(lin.log.lambda2(ht$ts, log(par.matrix[x,]), Ht, log(ML.est))))
  
  exp.true <- sapply(1:nrow(par.matrix), function(x) 
    exp.nev(par.matrix[x,], Tlim, Ht))
  
  # great difference using different steps for the approx
  exp.approx <- sapply(1:nrow(par.matrix), function(x) 
    exp.nev.lin(par.matrix[x,], Tlim, Ht, log(ML.est), by.s = by.s))
  
  df <- rbind(data.frame(par = par.matrix[,par.idx], 
                         log.lik = ll,
                         summ = sum.true,
                         exp.ev = exp.true, method = 'true'),
              data.frame(par = par.matrix[,par.idx], 
                         log.lik = ll.approx,
                         summ = sum.approx,
                         exp.ev = exp.approx, method = 'approx'))
  
  # first plot
  cols <- c("loglik"="#f04546","summ"="#3591d1","exp.ev"="#62c76b")
  
  # log scale
  pl.true.log <- df %>% 
    filter(method == 'true') %>%
    ggplot(aes(x = log(par), y = log.lik, colour = 'loglik')) + 
    geom_line() + 
    geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
    geom_line(aes(y = summ, colour = 'summ')) +
    geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+
    ylim(total.ylim) + 
    scale_colour_manual(name="Component",values=cols) +
    labs(title = 'true') + 
    xlab(paste0('log(',par.name,')'))
  
  # natural scale of the parameter
  pl.true <- df %>% 
    filter(method == 'true') %>%
    ggplot(aes(x = par, y = log.lik, colour = 'loglik')) + 
    geom_line() + 
    geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
    geom_line(aes(y = summ, colour = 'summ')) +
    geom_vline(xintercept = ML.est[par.idx], linetype = 2)+
    ylim(total.ylim) + 
    scale_colour_manual(name="Component",values=cols) +
    labs(title = 'true') + 
    xlab(par.name)
  
  
  # log scale
  pl.approx.log <- df %>% 
    filter(method == 'approx') %>%
    ggplot(aes(x = log(par), y = log.lik, colour = 'loglik')) + 
    geom_line() + 
    geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
    geom_line(aes(y = summ, colour = 'summ')) +
    geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+
    ylim(total.ylim) + 
    scale_colour_manual(name="Component",values=cols) +
    labs(title = 'approx') + 
    xlab(paste0('log(',par.name,')'))
  
  # natural scale of the parameter
  pl.approx <- df %>% 
    filter(method == 'approx') %>%
    ggplot(aes(x = par, y = log.lik, colour = 'loglik')) + 
    geom_line() + 
    geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
    geom_line(aes(y = summ, colour = 'summ')) +
    geom_vline(xintercept = ML.est[par.idx], linetype = 2)+
    ylim(total.ylim) + 
    scale_colour_manual(name="Component",values=cols) +
    labs(title = 'approx') + 
    xlab(par.name)
  
  # second plot
  pl.lik.log <- ggplot(df, aes(x = log(par), y = log.lik, color = method)) + 
    geom_line() + ylim(ll.ylim) + 
    geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2) + 
    theme(legend.position = 'bottom') + 
    labs(title = 'loglik') + 
    xlab(paste0('log(',par.name,')'))
  
  pl.lik <- ggplot(df, aes(x = par, y = log.lik, color = method)) + 
    geom_line() + ylim(ll.ylim) + 
    geom_vline(xintercept = ML.est[par.idx], linetype = 2) + 
    theme(legend.position = 'bottom') + 
    labs(title = 'loglik') + 
    xlab(par.name)
  
  
  pl.summ.log <- ggplot(df, aes(x = log(par), y = summ, color = method)) + 
    geom_line() + 
    geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+ 
    ylim(ss.ylim) + 
    labs(title = 'summation') + 
    theme(legend.position = 'bottom')+ 
    xlab(paste0('log(',par.name,')'))
  
  pl.summ <- ggplot(df, aes(x = par, y = summ, color = method)) + 
    geom_line() + 
    geom_vline(xintercept = ML.est[par.idx], linetype = 2)+ 
    ylim(ss.ylim) + 
    labs(title = 'summation') + 
    theme(legend.position = 'bottom')+ 
    xlab(par.name)
  
  pl.exp.log <- ggplot(df, aes(x = log(par), y = exp.ev, color = method)) + 
    geom_line() + ylim(ee.ylim) + 
    geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+ 
    theme(legend.position = 'bottom') +
    labs(title = 'integral') + 
    xlab(paste0('log(',par.name,')'))
  
  pl.exp <- ggplot(df, aes(x = par, y = exp.ev, color = method)) + 
    geom_line() + ylim(ee.ylim) + 
    geom_vline(xintercept = ML.est[par.idx], linetype = 2)+ 
    theme(legend.position = 'bottom') +
    labs(title = 'integral') + 
    xlab(par.name)
  
  list(natural = list(one = list(pl.true, pl.approx), 
                      three = list(pl.lik, pl.summ, pl.exp)),
       log = list(one = list(pl.true.log, pl.approx.log), 
                  three = list(pl.lik.log, pl.summ.log, pl.exp.log)))
  
}



toplot.lambda.comparison <- 
  function(par.values, par.idx, par0, ML.est, tt, Ht, par.name = 'par'){
  
  if(par.idx == 1){
    par.matrix <- cbind(par.values, ML.est[2], 
                        ML.est[3], ML.est[4])
    par0 <- c(par0, ML.est[2], ML.est[3], ML.est[4])
    }
  if(par.idx == 2){
    par.matrix <- cbind(ML.est[1], par.values, 
                        ML.est[3], ML.est[4])
    par0 <- c(ML.est[1], par0, ML.est[3], ML.est[4])
    }
  if(par.idx == 3){
    par.matrix <- cbind(ML.est[1], ML.est[2], 
                        par.values, ML.est[4])
    par0 <- c(ML.est[1], ML.est[2], par0, ML.est[4])
    }
  if(par.idx == 4){
    par.matrix <- cbind(ML.est[1], ML.est[2], 
                        ML.est[3], par.values)
    par0 <- c(ML.est[1], ML.est[2], ML.est[3], par0)
    }
  
  ll <- sapply(1:nrow(par.matrix), function(x) 
      log.lambda(tt, par.matrix[x,], Ht))
    
  
  ll.approx <- sapply(1:nrow(par.matrix), function(x) 
      lin.log.lambda(tt, log(par.matrix[x,]), 
                     Ht, log(par0)))
    
  df <- rbind(data.frame(par = par.matrix[,par.idx], 
                         loglambda = ll,
                         method = 'exact'),
              data.frame(par = par.matrix[,par.idx], 
                         loglambda = ll.approx,
                         method = 'linear'))
  
  pl.log <- ggplot(df, aes(x = log(par), y = loglambda, color = method,
                                 linetype = method)) + geom_line() +
    geom_vline(xintercept = log(par0[par.idx]), linetype = 2) + 
    xlab(paste0('log(',par.name,')'))
  
  pl <- ggplot(df, aes(x = par, y = loglambda, color = method,
                             linetype = method)) + geom_line() +
    geom_vline(xintercept = par0[par.idx], linetype = 2) +
    xlab(par.name)
  
  multiplot(pl.log, pl, cols = 2)
}


# to compute log.I
log.I <- function(Tlim, thetas, Ht){
  lw <- thetas[3]*exp(thetas[4]) - exp(thetas[4])*log(Tlim - Ht + exp(thetas[3]))
  thetas[2] + log(1 - exp(lw)) 
} 


# to compute derivative wrt theta3 of logI
log.I.theta3.der <- function(Tlim, thetas, Ht){
  # we compute the log first
  nn <- exp(thetas[2])*I.h2(Tlim, exp(thetas[3]), exp(thetas[4]), Ht)
  log.app <- thetas[2] + (thetas[3]*exp(thetas[4]) + thetas[4]) + (-exp(thetas[4]) - 1)*log(Tlim - Ht + exp(thetas[3])) + log(Tlim - Ht)
  
  return(-exp(log.app)/nn)
}

log.I.theta4.der <- function(Tlim, thetas, Ht){
  # compute the function (denominator)
  nn <- exp(thetas[2])*I.h2(Tlim, exp(thetas[3]), exp(thetas[4]), Ht)
  # we actually compute log(-der I.h)
  lg <- thetas[2] + thetas[4] + thetas[3]*exp(thetas[4]) -exp(thetas[4])*log(Tlim - Ht + exp(thetas[3])) 
  
  cc <- thetas[3] - log(Tlim - Ht + exp(thetas[3]))
  return(-exp(lg)*cc/nn)
}


# linearized version of lin.log.I
lin.log.I <- function(Tlim, thetas, Ht, thetas0){
  l0 <- log.I(Tlim, thetas0, Ht)
  der.theta2 <- (thetas[2] - thetas0[2])
  der.theta3 <- (thetas[3] - thetas0[3])*log.I.theta3.der(Tlim, thetas0, Ht)
  der.theta4 <- (thetas[4] - thetas0[4])*log.I.theta4.der(Tlim, thetas0, Ht)
  l0 + der.theta2 + der.theta3 + der.theta4
}

# here makes sense to do the comparison only for par.idx = 2,3,4 because
# mu does not play a role 

toplot.I.comparison <- 
  function(par.values, par.idx, par0, ML.est, Tlim, Ht, par.name = 'par'){
    
    if(par.idx == 2){
      par.matrix <- cbind(ML.est[1], par.values, 
                          ML.est[3], ML.est[4])
      par0 <- c(ML.est[1], par0, ML.est[3], ML.est[4])
    }
    if(par.idx == 3){
      par.matrix <- cbind(ML.est[1], ML.est[2], 
                          par.values, ML.est[4])
      par0 <- c(ML.est[1], ML.est[2], par0, ML.est[4])
    }
    if(par.idx == 4){
      par.matrix <- cbind(ML.est[1], ML.est[2], 
                          ML.est[3], par.values)
      par0 <- c(ML.est[1], ML.est[2], ML.est[3], par0)
    }
    
    logI <- sapply(1:nrow(par.matrix), function(x) 
      log.I(Tlim, log(par.matrix[x,]), Ht))
    
    
    logI.approx <- sapply(1:nrow(par.matrix), function(x) 
      lin.log.I(Tlim, log(par.matrix[x,]), 
                     Ht, log(par0)))
    
    df <- rbind(data.frame(par = par.matrix[,par.idx], 
                           logI = logI,
                           method = 'exact'),
                data.frame(par = par.matrix[,par.idx], 
                           logI = logI.approx,
                           method = 'linear'))
    
    pl.log <- ggplot(df, aes(x = log(par), y = logI, color = method,
                             linetype = method)) + geom_line() +
      geom_vline(xintercept = log(par0[par.idx]), linetype = 2) + 
      xlab(paste0('log(',par.name,')'))
    
    pl <- ggplot(df, aes(x = par, y = logI, color = method,
                         linetype = method)) + geom_line() +
      geom_vline(xintercept = par0[par.idx], linetype = 2) +
      xlab(par.name)
    
    
    pl.log.exp <- ggplot(df, aes(x = log(par), y = exp(logI), color = method,
                             linetype = method)) + geom_line() +
      geom_vline(xintercept = log(par0[par.idx]), linetype = 2) + 
      xlab(paste0('log(',par.name,')'))
    
    pl.exp <- ggplot(df, aes(x = par, y = exp(logI), color = method,
                         linetype = method)) + geom_line() +
      geom_vline(xintercept = par0[par.idx], linetype = 2) +
      xlab(par.name)
    
    
    return(list(logI = list(pl.log, pl),
                I = list(pl.log.exp, pl.exp)))
  }



toplot.exp.approx.comparison <- 
  function(par.values, par.idx, par0, ML.est, Tlim, Ht, 
           par.name = 'par', ee.lim = c(0,1000)){
    
    if(par.idx == 1){
      par.matrix <- cbind(par.values, ML.est[2], 
                          ML.est[3], ML.est[4])
      par0 <- c(par0, ML.est[2], ML.est[3], ML.est[4])
    }
    if(par.idx == 2){
      par.matrix <- cbind(ML.est[1], par.values, 
                          ML.est[3], ML.est[4])
      par0 <- c(ML.est[1], par0, ML.est[3], ML.est[4])
    }
    if(par.idx == 3){
      par.matrix <- cbind(ML.est[1], ML.est[2], 
                          par.values, ML.est[4])
      par0 <- c(ML.est[1], ML.est[2], par0, ML.est[4])
    }
    if(par.idx == 4){
      par.matrix <- cbind(ML.est[1], ML.est[2], 
                          ML.est[3], par.values)
      par0 <- c(ML.est[1], ML.est[2], ML.est[3], par0)
    }
    
    exp.v <- sapply(1:nrow(par.matrix), function(x) 
      exp.nev(par.matrix[x,], Tlim, Ht))
    print('first')
    exp.v.approx1 <- sapply(1:nrow(par.matrix), function(x) 
      exp.nev.lin(par.matrix[x,], Tlim, Ht, log(par0)))
    print('sec')
    exp.v.approx2 <- sapply(1:nrow(par.matrix), function(x) 
      exp.nev.lin2(par.matrix[x,], Tlim, Ht, log(par0)))
    print('third')
    df <- rbind(data.frame(par = par.matrix[,par.idx], 
                           exp.v = exp.v,
                           method = 'exact'),
                data.frame(par = par.matrix[,par.idx], 
                           exp.v = exp.v.approx1,
                           method = 'first approx'),
                data.frame(par = par.matrix[,par.idx], 
                           exp.v = exp.v.approx2,
                           method = 'second approx'))
    
    pl.log <- ggplot(df, aes(x = log(par), y = exp.v, color = method,
                             linetype = method)) + 
      geom_line() + 
      geom_vline(xintercept = log(par0[par.idx]), linetype = 2) + 
      xlab(paste0('log(',par.name,')')) + 
      ylim(ee.lim)
      
    pl <- ggplot(df, aes(x = par, y = exp.v, color = method,
                         linetype = method)) + 
      geom_line() + 
      geom_vline(xintercept = par0[par.idx], linetype = 2) + 
      xlab(par.name)+
      ylim(ee.lim)
    
    multiplot(pl.log, pl, cols = 2)
  }


toplot.loglik.dec.comparison <- 
  function(par.values, par.idx, ML.est, Tlim, Ht, by.s = 0.01, par.name = 'par',
           ll.ylim = c(400, 700), ss.ylim = c(700,1000), 
           ee.ylim = c(100,350), total.ylim = c(0,1000)){
    
    if(par.idx == 1){par.matrix <- cbind(par.values, ML.est[2], 
                                         ML.est[3], ML.est[4])}
    if(par.idx == 2){par.matrix <- cbind(ML.est[1], par.values, 
                                         ML.est[3], ML.est[4])}
    if(par.idx == 3){par.matrix <- cbind(ML.est[1], ML.est[2], 
                                         par.values, ML.est[4])}
    if(par.idx == 4){par.matrix <- cbind(ML.est[1], ML.est[2], 
                                         ML.est[3], par.values)}
    # true loglik
    ll <- sapply(1:nrow(par.matrix), function(x)
      hawkes.loglik(par.matrix[x,], Tlim, Ht))
    
    # first loglik approx
    ll.approx <- sapply(1:nrow(par.matrix), function(x) 
      hawkes.loglik.lin(par.matrix[x,], Tlim, Ht, log(ML.est), by.s = by.s))
    
    # second approx loglik
    ll.approx2 <- sapply(1:nrow(par.matrix), function(x) 
      hawkes.loglik.lin2(par.matrix[x,], Tlim, Ht, log(ML.est)))
    
    # true summation
    sum.true <- sapply(1:nrow(par.matrix), function(x) 
      sum(log.lambda(ht$ts, par.matrix[x,], Ht)))
    
    # the summation approximation is the same for both methods
    sum.approx <- sapply(1:nrow(par.matrix), function(x) 
      sum(lin.log.lambda2(ht$ts, log(par.matrix[x,]), Ht, log(ML.est))))
    
    # true expected value
    exp.true <- sapply(1:nrow(par.matrix), function(x) 
      exp.nev(par.matrix[x,], Tlim, Ht))
    
    # first exp value approximation
    exp.approx <- sapply(1:nrow(par.matrix), function(x) 
      exp.nev.lin(par.matrix[x,], Tlim, Ht, log(ML.est), by.s = by.s))
    
    # second exp value approximation
    exp.approx2 <- sapply(1:nrow(par.matrix), function(x) 
      exp.nev.lin2(par.matrix[x,], Tlim, Ht, log(ML.est)))
    
    df <- rbind(data.frame(par = par.matrix[,par.idx], 
                           log.lik = ll,
                           summ = sum.true,
                           exp.ev = exp.true, method = 'true'),
                data.frame(par = par.matrix[,par.idx], 
                           log.lik = ll.approx,
                           summ = sum.approx,
                           exp.ev = exp.approx, method = 'first approx'),
                data.frame(par = par.matrix[,par.idx], 
                           log.lik = ll.approx2,
                           summ = sum.approx,
                           exp.ev = exp.approx2, method = 'second approx'))
    
    # first plot
    cols <- c("loglik"="#f04546","summ"="#3591d1","exp.ev"="#62c76b")
    
    # log scale
    pl.true.log <- df %>% 
      filter(method == 'true') %>%
      ggplot(aes(x = log(par), y = log.lik, colour = 'loglik')) + 
      geom_line() + 
      geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
      geom_line(aes(y = summ, colour = 'summ')) +
      geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+
      ylim(total.ylim) + 
      scale_colour_manual(name="Component",values=cols) +
      labs(title = 'true') + 
      xlab(paste0('log(',par.name,')'))
    
    # natural scale of the parameter
    pl.true <- df %>% 
      filter(method == 'true') %>%
      ggplot(aes(x = par, y = log.lik, colour = 'loglik')) + 
      geom_line() + 
      geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
      geom_line(aes(y = summ, colour = 'summ')) +
      geom_vline(xintercept = ML.est[par.idx], linetype = 2)+
      ylim(total.ylim) + 
      scale_colour_manual(name="Component",values=cols) +
      labs(title = 'true') + 
      xlab(par.name)
    
    
    # log scale
    pl.approx.log <- df %>% 
      filter(method == 'first approx') %>%
      ggplot(aes(x = log(par), y = log.lik, colour = 'loglik')) + 
      geom_line() + 
      geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
      geom_line(aes(y = summ, colour = 'summ')) +
      geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+
      ylim(total.ylim) + 
      scale_colour_manual(name="Component",values=cols) +
      labs(title = 'first approx') + 
      xlab(paste0('log(',par.name,')'))
    
    # natural scale of the parameter
    pl.approx <- df %>% 
      filter(method == 'first approx') %>%
      ggplot(aes(x = par, y = log.lik, colour = 'loglik')) + 
      geom_line() + 
      geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
      geom_line(aes(y = summ, colour = 'summ')) +
      geom_vline(xintercept = ML.est[par.idx], linetype = 2)+
      ylim(total.ylim) + 
      scale_colour_manual(name="Component",values=cols) +
      labs(title = 'first approx') + 
      xlab(par.name)
    
    pl.approx2.log <- df %>% 
      filter(method == 'second approx') %>%
      ggplot(aes(x = log(par), y = log.lik, colour = 'loglik')) + 
      geom_line() + 
      geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
      geom_line(aes(y = summ, colour = 'summ')) +
      geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+
      ylim(total.ylim) + 
      scale_colour_manual(name="Component",values=cols) +
      labs(title = 'second approx') + 
      xlab(paste0('log(',par.name,')'))
    
    # natural scale of the parameter
    pl.approx2 <- df %>% 
      filter(method == 'second approx') %>%
      ggplot(aes(x = par, y = log.lik, colour = 'loglik')) + 
      geom_line() + 
      geom_line(aes(y = exp.ev, colour = 'exp.ev')) + 
      geom_line(aes(y = summ, colour = 'summ')) +
      geom_vline(xintercept = ML.est[par.idx], linetype = 2)+
      ylim(total.ylim) + 
      scale_colour_manual(name="Component",values=cols) +
      labs(title = 'second approx') + 
      xlab(par.name)
    
    
    
    # second plot
    pl.lik.log <- ggplot(df, aes(x = log(par), y = log.lik, color = method,
                                 linetype = method)) + 
      geom_line() + ylim(ll.ylim) + 
      geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2) + 
      theme(legend.position = 'bottom') + 
      labs(title = 'loglik') + 
      xlab(paste0('log(',par.name,')'))
    
    pl.lik <- ggplot(df, aes(x = par, y = log.lik, color = method,
                             linetype = method)) + 
      geom_line() + ylim(ll.ylim) + 
      geom_vline(xintercept = ML.est[par.idx], linetype = 2) + 
      theme(legend.position = 'bottom') + 
      labs(title = 'loglik') + 
      xlab(par.name)
    
    
    pl.summ.log <- ggplot(df, aes(x = log(par), y = summ, color = method,
                                  linetype = method)) + 
      geom_line() + 
      geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+ 
      ylim(ss.ylim) + 
      labs(title = 'summation') + 
      theme(legend.position = 'bottom')+ 
      xlab(paste0('log(',par.name,')'))
    
    pl.summ <- ggplot(df, aes(x = par, y = summ, color = method,
                              linetype = method)) + 
      geom_line() + 
      geom_vline(xintercept = ML.est[par.idx], linetype = 2)+ 
      ylim(ss.ylim) + 
      labs(title = 'summation') + 
      theme(legend.position = 'bottom')+ 
      xlab(par.name)
    
    pl.exp.log <- ggplot(df, aes(x = log(par), y = exp.ev, color = method,
                                 linetype = method)) + 
      geom_line() + ylim(ee.ylim) + 
      geom_vline(xintercept = log(ML.est[par.idx]), linetype = 2)+ 
      theme(legend.position = 'bottom') +
      labs(title = 'integral') + 
      xlab(paste0('log(',par.name,')'))
    
    pl.exp <- ggplot(df, aes(x = par, y = exp.ev, color = method,
                             linetype = method)) + 
      geom_line() + ylim(ee.ylim) + 
      geom_vline(xintercept = ML.est[par.idx], linetype = 2)+ 
      theme(legend.position = 'bottom') +
      labs(title = 'integral') + 
      xlab(par.name)
    
    list(natural = list(one = list(pl.true, pl.approx, pl.approx2), 
                        three = list(pl.lik, pl.summ, pl.exp)),
         log = list(one = list(pl.true.log, pl.approx.log, pl.approx2.log), 
                    three = list(pl.lik.log, pl.summ.log, pl.exp.log)))
    
  }
