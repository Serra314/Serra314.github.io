---
title: "Spatio-Temporal Hawkes"
author: "Francesco Serafini"
date: "28/07/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source('spatial_ETAS_utils.R')
```

# Target Model 

Hawkes process model with conditional intensity at time $t$ and location $\textbf s$ given the history of the process at time $t, \, \mathcal H_t$, is given by:

$$
\lambda(t, \textbf s | \mathcal H_t) = \mu(\textbf s) + K\sum_{i: t_i < t} g_m(m_i)g_t(t - t_i)g_s(\textbf s - \textbf s_i)
$$

with expected number of point in a region $A \times [T_1, T_2]$

$$
\begin{aligned}
\Lambda(T_1, T_2, A) & = \int_A \int_{T_1}^{T_2} \lambda(t, \textbf s | \mathcal H_t)dt d\textbf s \\ \\ 
& = (T_2 - T_1)\int_A \mu(\textbf s)d\textbf s + K \sum_{i} g_m(m_i)\int_A \int_{max(t_i, T_1)}^{T_2} g_t(t - t_i) g_s(|\textbf s - \textbf s_i|)dtd\textbf s \\ \\ 
& = (T_2 - T_1)\int_A \mu(\textbf s)d\textbf s + K \sum_{i} g_m(m_i)I_t(t_i, T_1, T_2) I_s(\textbf s_i, A)
\end{aligned}
$$

where the summation is over $i : t_i \in H_{T_2}$ the history of the process up to time $T_2$ and 

$$
I_t(t_i, T_1, T_2) = \int_{max(t_i, T_1)}^{T_2} g_t(t - t_i)dt
$$

$$
I_s(s_i, A) = \int_A g_s(\textbf s - \textbf s_i)d\textbf s
$$

The log-likelihood is given by

$$
\mathcal L = - \left( (T_2 - T_1)\int_A \mu(\textbf s)d\textbf s + K \sum_{i} g_m(m_i)I_t(t_i, T_1, T_2) I_s(\textbf s_i, A) \right) + \sum_i \log \left( \mu(\textbf s_i) + K\sum_{j: t_j < t_i} g_m(m_j)g_t(t_i - t_j)g_s(|\textbf s_i - \textbf s_j |) \right)
$$

In our case

$$
\mu(\textbf s) = \exp(\theta_1) f(\textbf s)
$$

We assume $f(\textbf s)$ is given or estimated independently from others parameters.


$$
K = \exp(\theta_2)
$$

Considering a magnitude of completeness $M_0$, we consider a specific form for each triggering function. The first, $g_m(\cdot)$ represents the influence of the magnitude of past events on the present. We suppose that events with higher magnitude have a stronger effect and, therefore, we consider $\exp\theta_3$ which is a non-negative quantity.

$$
g_m(m) = \exp\{\exp(\theta_3)(m - M_0)\} 
$$

```{r}

toplot.gm <- function(theta3.seq, mm, M0){
  gm.list <- lapply(theta3.seq, function(x) data.frame(mags = mm,
                                           gm = sapply(mm, function(m) g.m(m, x, M0)),
                                           theta3 = x))
  gm.df <- bind_rows(gm.list)

  ggplot(gm.df, aes(x = mags, y = gm, color = as.factor(theta3), 
                    linetype = as.factor(theta3))) + 
           geom_line() + 
    labs(color = "theta3", linetype = 'theta3')
  
}

M0 <- 2.5
mm <- seq(M0 + 0.1, 9, by = 0.1)

theta3.seq <- seq(-0.5, 0, by = 0.1)
pl.left <- toplot.gm(theta3.seq, mm, M0)

theta3.seq <- seq(0, 0.5, by = 0.1)
pl.right <- toplot.gm(theta3.seq, mm, M0)


multiplot(pl.left, pl.right, cols = 2)
```



The second function, $g_t(\cdot)$ represents the temporal decay of the influence of a past event on the present. It is given by the Omori's law and has two parameters $\theta_4$ and $\theta_5$

$$
g_t(t - t_i) = \frac{1}{(t - t_i + \exp\theta_4)^{1 + \exp \theta_5}}
$$

```{r}
source('ETAS_utils.R')
tt <- seq(1e-5, 5 + 1e-5, by = 0.1)
ht <- 0

th4.seq <- seq(-3, -1, by = 0.5)
th5.seq <- seq(-1, 1, by = 0.5)

th.gr <- expand.grid(th4.seq, th5.seq)
gt.list <- lapply(1:nrow(th.gr), function(i) 
  data.frame(t = tt,
             gt = g.t(tt, th.gr[i, 1], th.gr[i, 2], ht),
             params = paste(th.gr[i,1], th.gr[i,2], sep = '|'),
             th4 = th.gr[i,1], th5 = th.gr[i,2]))

gt.df <- bind_rows(gt.list)

pl.left <- 
  ggplot(gt.df[gt.df$th4 == -3,], aes(x = t, y = gt, color = params, linetype = params)) + 
  geom_line() + ylim(0, 250)

pl.right <- 
  ggplot(gt.df[gt.df$th5 == 0.5,], aes(x = t, y = gt, color = params, linetype = params)) + 
  geom_line()+ ylim(0, 250)

multiplot(pl.left, pl.right, cols = 2)
```


$$
g_s(\textbf s - \textbf s_i) = \frac{1}{2\pi}(\text{det}\Sigma)^{-1/2}\exp\{-(\textbf s - \textbf s_i)^T \Sigma^{-1} (\textbf s - \textbf s_i)\}
$$

Where $\Sigma$ is a $2 \times 2$ covariance matrix. It has to be symmetric so, in this case, we need to specify three elements which will determine the shape of the triggering function. The location is governed by the mean which, in this case, is considered to be the observed point $\textbf s_i$. 

```{r}
library(mvtnorm)

toplot.gs <- function(Mu, Sigma, x.seq, y.seq){
  
  df <- expand.grid(x.seq, y.seq)
  colnames(df) <- c('x', 'y')
  df$density <- sapply(1:nrow(df), function(x) dmvnorm(df[x,1:2], mean = Mu,
                                                     sigma = Sigma))

  ggplot(df, aes(x = x, y = y, fill = density, z = density)) + 
    geom_tile() + geom_contour() + 
    scale_fill_viridis() + 
    geom_point(aes(x = Mu[1], y = Mu[2])) + 
    labs(title = paste0('Sigma.xy = ', Sigma[2,1])) + 
    theme(legend.position = 'bottom')
}

Mu = rep(0.5, 2)
x.seq <- seq(0,1,by = 0.02)
y.seq <- seq(0,1,by = 0.02)

# indipendence
Sigma = matrix(c(1,0,0, 1), byrow = T, ncol = 2)
plotgs.1 <- toplot.gs(Mu, Sigma, x.seq, y.seq)

# negative corr
Sigma = matrix(c(1,-0.5,-0.5, 1), byrow = T, ncol = 2)
plotgs.2 <- toplot.gs(Mu, Sigma, x.seq, y.seq)

# positive corr
Sigma = matrix(c(1, 0.5, 0.5, 1), byrow = T, ncol = 2)
plotgs.3 <- toplot.gs(Mu, Sigma, x.seq, y.seq)

multiplot(plotgs.1, plotgs.2, plotgs.3, cols = 3)
```


Given the above specification of the triggering functions, we need to integrate them to retrieve the expected number of points in a given region of the domain. 

For the time triggering function: 

$$
\begin{aligned}
I_t(t_i, T_1, T_2) & = \int_{max(t_i, T_1)}^{T_2} g_t(t - t_i)dt \\ \\
& = \int_{max(t_i, T_1)}^{T_2} (t - t_i + \exp\theta_4)^{-1 -\exp\theta_5} dt \\ \\
& = \frac{(\max(0, T_1 - t_i) + \exp\theta_4)^{-\exp\theta_5} - (T_2 - t_i + \exp\theta_4)^{-\exp\theta_5}}{\exp \theta_5} 
\end{aligned}
$$

For the spatial triggering function, being a multivariate Gaussian density function:

$$
\begin{aligned}
I_g(A) & = \int_A g_s(\textbf s - \textbf s_i)d\textbf s \\ \\ 
& = \Pr(\textbf Z \in A)
\end{aligned}
$$

Where $\textbf Z \sim N(\textbf s_i, \Sigma)$ it's a multivariate Gaussian distribution with mean given by the observed location $\textbf s_i$ and covariance matrix $\Sigma$.

```{r}
x_coords <- c(0,1,1,0,0)
y_coords <- c(0,0,1,1,0)

poly1 <- sp::Polygon(cbind(x_coords,y_coords))
bdy <- sp::Polygons(list(poly1), ID = "A")
bdy <- sp::SpatialPolygons(list(bdy))
crswgs <- CRS("+proj=longlat +datum=WGS84")
proj4string(bdy) <- crswgs
bdy <- spTransform(bdy, crswgs)

mesh.n <- inla.mesh.2d(boundary = bdy, max.edge = 0.05)
mesh.n$crs <- crswgs

ggplot() + gg(mesh.n)
```


```{r}
# effect of magnitude 3 vs 6 

Ht <- data.frame(long = c(0.25, 0.75),
                 lat = c(0.75, 0.25),
                 ts = 0.3,
                 mags = c(3,6))

theta.v <- log(c(1e-5, 1e-1, 0.9, 1e-2, 0.1, 0.002, 0.002, 0.0019)) 
current <- data.frame(ts = 0.5, 
                      long = mesh.n$loc[,1],
                      lat = mesh.n$loc[,2])

loglambda <- sapply(1:nrow(current), function(x) 
  logLambda(current[x,], theta.v, Ht, M0))

mm <- inla.mesh.projector(mesh.n, dims = c(100, 100))
mm2 <- inla.mesh.project(mm, exp(loglambda))  
mm3 <- pixels(mesh.n, nx = 100, ny = 100)
mm3$lambda <- as.vector(mm2)

ggplot() + gg(mm3) + 
  scale_fill_viridis() +
  geom_point(data = Ht, 
             mapping = aes(x = long, y = lat, shape = factor(mags)),
             color = 'red') 
```

```{r}
# effect of time
Ht <- data.frame(long = c(0.25, 0.75),
                 lat = c(0.75, 0.25),
                 ts = c(0.1, 0.4),
                 mags = c(6,6))

current <- data.frame(ts = 0.5, 
                      long = mesh.n$loc[,1],
                      lat = mesh.n$loc[,2])

loglambda <- sapply(1:nrow(current), function(x) 
  logLambda(current[x,], theta.v, Ht, M0))

mm <- inla.mesh.projector(mesh.n, dims = c(100, 100))
mm2 <- inla.mesh.project(mm, exp(loglambda))  
mm3 <- pixels(mesh.n, nx = 100, ny = 100)
mm3$lambda <- as.vector(mm2)

ggplot() + gg(mm3) + 
  scale_fill_viridis() +
  geom_point(data = Ht, 
             mapping = aes(x = long, y = lat, shape = factor(ts)),
             color = 'red') 

```


```{r}
# a <- spsample(bdy, 10, 'random')
# Ht <- data.frame(long = a@coords[,1],
#                  lat = a@coords[,2],
#                  ts = runif(10, 0, 0.5 - 1e-4),
#                  mags = runif(10, 2.5, 7))
# 
# Ht$ts.class <- cut(Ht$ts - 0.5, breaks = c(-0.5, -0.4, -0.3, -0.2, 0))
# 

# save(Ht, file = 'Ht_example.RData')

load('Ht_example.RData')

theta.v <- log(c(1e-5, 1e-1, 0.9, 1e-2, 0.1, 0.002, 0.002, 0.0019)) 
current <- data.frame(ts = 0.5, 
                      long = mesh.n$loc[,1],
                      lat = mesh.n$loc[,2])

loglambda <- sapply(1:nrow(current), function(x) 
  logLambda(current[x,], theta.v, Ht, M0))

mm <- inla.mesh.projector(mesh.n, dims = c(100, 100))
mm2 <- inla.mesh.project(mm, loglambda)  
mm3 <- pixels(mesh.n, nx = 100, ny = 100)
mm3$loglambda <- as.vector(mm2)


ggplot() + gg(mm3) +
  geom_point(data = Ht, 
             mapping = aes(x = long, y = lat, size = mags, shape = ts.class),
             color = 'red') +
  scale_fill_viridis() +
  scale_color_viridis(option = 'magma') 
```

```{r}
# estimated number of points
ips <- ipoints(mesh.n)
lambda.app.int <- sum(ips$weight*exp(loglambda))
lambda.app.int

```

```{r}
# sample points
n.points <- rpois(1, sum(ips$weight*exp(loglambda)))

s <- Sys.time()
ss <- point_sampler(loglambda, bdy, mesh.n, n.points, crswgs)
Sys.time() - s

ggplot() + gg(mm3) + 
  gg(ss) +
  geom_point(data = Ht, 
             mapping = aes(x = long, y = lat, size = mags, shape = ts.class),
             color = 'red') + 
  scale_fill_viridis()

```

# ITALY

```{r}
italy.collection <- read.delim('ITALY_BDY/italy.collection.nodes.dat', sep = '', header = FALSE)
colnames(italy.collection) <- c('long', 'lat')
coordinates(italy.collection) <- ~ long + lat
proj4string(italy.collection) <- crswgs
italy.collection <- spTransform(italy.collection, crswgs)

italy.grid <- SpatialPixelsDataFrame(italy.collection, proj4string = crswgs,
                            data = data.frame(id = 1:11207))
italy.contour <- adehabitatMA::getcontour(italy.grid)

class(italy.contour)
italy.contour@proj4string
plot(italy.contour)

```

```{r}
italy.mesh <- inla.mesh.2d(boundary = italy.contour, max.edge = c(0.2, 0.3))
italy.mesh$crs <- crswgs
italy.mesh$n

ggplot() + gg(italy.mesh) + gg(italy.contour, color = 'blue')
```

# Problems with Thinning technique for sampling

In case we have a large low intensity area, the thinning technique may be really slow. This is because the majority of the homogeneously sampled points will be discarded and we need an high number of samples to reach a specified number of retained points. 

Practical example: simultaneously simulate the aftershocks of a set of events. We take 100 points at random and we want to generate their aftershocks.   

```{r}
a <- spsample(italy.contour, 10, 'random')
Ht <- data.frame(long = a@coords[,1],
                 lat = a@coords[,2],
                 ts = runif(100, 0, 0.5 - 1e-4),
                 mags = runif(100, 2.5, 7))

Ht$ts.class <- cut(Ht$ts - 0.5, breaks = c(-0.5, -0.4, -0.3, -0.2, 0))


# save(Ht, file = 'Ht_example.RData')

#load('Ht_example.RData')

theta.v <- log(c(1e-5, 1e-1, 0.9, 1e-2, 0.1, 0.002, 0.002, 0.0019)) 
current <- data.frame(ts = 0.5, 
                      long = italy.mesh$loc[,1],
                      lat = italy.mesh$loc[,2])

loglambda <- sapply(1:nrow(current), function(x) 
  logLambda(current[x,], theta.v, Ht, M0))


italy.pixels <- pixels(italy.mesh, nx = 400, ny = 400)
mm <- inla.mesh.projector(italy.mesh, loc = italy.pixels@coords, crs = crswgs)
mm2 <- inla.mesh.project(mm, loglambda)  
italy.pixels$loglambda <- as.vector(mm2)


ggplot() + gg(italy.pixels) +
   geom_point(data = Ht,
              mapping = aes(x = long, y = lat),
              color = 'red', size = 0.2) +
  scale_fill_viridis() +
  scale_color_viridis(option = 'magma') 

```

```{r}
ips <- ipoints(italy.mesh)
lambda.app.int <- sum(ips$weight*exp(loglambda))
lambda.app.int
```

```{r, eval = FALSE}
n.points <- rpois(1, sum(ips$weight*exp(loglambda)))

s <- Sys.time()
ss <- point_sampler(loglambda, italy.contour, italy.mesh, n.points, crswgs)
Sys.time() - s

ggplot() + gg(italy.pixels) + 
  gg(ss) +
  geom_point(data = Ht, 
             mapping = aes(x = long, y = lat),
             color = 'red') + 
  scale_fill_viridis()

```


# What I think is the right way

The sampling should work as follows:

1. Sample background points according to field. So, we already need two cases here: a) the field is normalized and the number of points to be simulated is given and we have just to place them. b) the field is not normalized and we have to approximate the number of points to be simualted and then place them.

2. For each point: 
.a) determine the number of aftershocks generated ($K g_m(m_i)*I_t(t_i, T_{lim})*I_s(W)$, need a function for that). 
.b) place them in time (need a function for that). 
.c) determine the area of interest (we need a function that builds a SpatialPolygon delimiting the aftershock region, we can make search the right polygon looking at the number of aftershock generated in the aftershock region $A$, that would be $K g_m(m_i)*I_t(t_i, T_{lim})*I_s(A)$ and we can use the same function as before, I think it may be even be optimized given that we know the shape parameters of the spatial triggering).
.d) use thinning technique to place them in the region $A$, considering how $A$ is determining the problem of discarding too many events should be alleviated.



```{r}
# to create a circle 
#library(sampSurf)

Ht <- data.frame(long = c(0.75, 0.25), 
                 lat = c(0.25, 0.75), 
                 ts = c(0.4, 0.5 - 1e-4), 
                 mags = 6)

Ht <- data.frame(long = 0.5, 
                 lat = 0.5, 
                 ts = 0.4, 
                 mags = 6)

theta.v <- log(c(1e-5, 1e-1, 0.9, 1e-2, 0.1, 0.002, 0.002, 0.0019)) 
Sigma <- exp(matrix(c(theta.v[6], theta.v[8], theta.v[8], theta.v[6]), byrow = T, ncol = 2))
mesh.n <- inla.mesh.2d(boundary = bdy, max.edge = 0.02)
mesh.n$n

current <- data.frame(ts = 0.5, 
                      long = mesh.n$loc[,1],
                      lat = mesh.n$loc[,2])

loglambda <- sapply(1:nrow(current), function(x) 
  logLambda(current[x,], theta.v, Ht, M0))

m.pixels <- pixels(mesh.n, nx = 100, ny = 100)
mm <- inla.mesh.projector(mesh.n, loc = m.pixels@coords, crs = crswgs)
mm2 <- inla.mesh.project(mm, loglambda)  

m.pixels$loglambda <- as.vector(mm2)
m.pixels$lambda <- as.vector(inla.mesh.project(mm, exp(loglambda)))

m.pixels$gs <- sapply(1:nrow(m.pixels@coords), function(x) 
  g.s(m.pixels@coords[x,], cbind(Ht$long, Ht$lat), Sigma))

m.pixels$inout <- (m.pixels@coords[,1] >= 0.5 - 3*sqrt(Sigma[1,1])) & 
  (m.pixels@coords[,1] <= 0.5 + 3*sqrt(Sigma[1,1])) & (m.pixels@coords[,2] >= 0.5 - 3*sqrt(Sigma[2,2])) & 
  (m.pixels@coords[,2] <= 0.5 + 3*sqrt(Sigma[2,2]))


sum(m.pixels$gs*prod(m.pixels@grid@cellsize))
sum(m.pixels$gs[m.pixels$inout]*prod(m.pixels@grid@cellsize))

inout <- (mesh.n$loc[,1] >= 0.5 - 3*sqrt(Sigma[1,1])) & 
  (mesh.n$loc[,1] <= 0.5 + 3*sqrt(Sigma[1,1])) & (mesh.n$loc[,2] >= 0.5 - 3*sqrt(Sigma[2,2])) & 
  (mesh.n$loc[,2] <= 0.5 + 3*sqrt(Sigma[2,2]))


ips <- ipoints(mesh.n)
sum(ips$weight*exp(loglambda))
sum(ips$weight[inout]*exp(loglambda)[inout])

ss <- point_sampler(loglambda, bdy, mesh.n, 100, crswgs)

ggplot() + gg(m.pixels['inout']) +
   geom_point(data = Ht,
              mapping = aes(x = long, y = lat),
              color = 'red', size = 0.2) 


pl1 <- ggplot() + gg(m.pixels['lambda']) +
  #gg(ss) + 
  geom_point(data = Ht,
              mapping = aes(x = long, y = lat),
              color = 'red', size = 0.2) +
  scale_fill_viridis() 

pl2 <- ggplot() + gg(m.pixels['loglambda']) +
  gg(ss) +  
  geom_point(data = Ht,
              mapping = aes(x = long, y = lat),
              color = 'red', size = 0.2) +
    scale_fill_viridis() 

multiplot(pl1, pl2, cols = 2)


```

The fastest way to place the points in space accordingly to their spatial triggering function is to use the function \texttt{rmvnorm()} to sample from a multivariate gaussian distribution. 

```{r}
# we are going to use only the spatial triggering function as loglambda
# because we are going to use it in this way.
Ht.loc <- data.frame(long = 0.5, lat = 0.5)
x_coords <- c(0, 0, 1, 1, 0)
y_coords <- c(0, 1, 1, 0, 0)
poly <- sp::Polygon(cbind(x_coords,y_coords))
bdy <- sp::Polygons(list(poly), ID = "A")
bdy <- sp::SpatialPolygons(list(bdy))
proj4string(bdy) <- crswgs
bdy <- spTransform(bdy, crswgs)
```


```{r}
sample.given.loc <- function(n.ev, bdy, Ht.loc, Sigma, crsobj){
  
  samp.points <- SpatialPoints(data.frame(x = 0, y = 0))
  samp.points <- samp.points[-1,]
  proj4string(samp.points) <- crswgs
  num <- 0
  
  while (num < n.ev){
    pts.matrix <- rmvnorm(n.ev, mean = as.numeric(Ht.loc), sigma = Sigma)
    pts <- data.frame(x = pts.matrix[,1], y = pts.matrix[,2])
    coordinates(pts) <- ~ x + y
    proj4string(pts) <- crsobj
    pts <- spTransform(pts, crsobj)
    # discard the ones outside bdy
    pts <- crop(pts, bdy)
    
    if(length(pts) > 0){
      samp.points <- rbind(samp.points, pts)
      num <- length(samp.points)
    }
    else{
      #print('no retained')
    }
  }
    
  ## Keep exactly cat_n points, choose these randomly from all of the points we've kept so far
  kp <- sample(seq(1, length(samp.points), by=1), n.ev, replace=FALSE)
  samp.points <- samp.points[kp,]
  samp.points
}


```

```{r}
m.pixels <- pixels(sample.p$mesh, nx = 100, ny = 100)
mm <- inla.mesh.projector(sample.p$mesh, loc = m.pixels@coords, crs = crswgs)
mm2 <- inla.mesh.project(mm, sample.p$logl)  
m.pixels$loglambda <- as.vector(mm2)
m.pixels$lambda <- exp(m.pixels$loglambda)


ss3 <- rmvnorm(100, mean = c(0.5, 0.5), sigma = Sigma)
ss3 <- data.frame(long = ss3[,1], lat = ss3[,2])
coordinates(ss3) <- ~ long + lat

pl1 <- ggplot() + gg(m.pixels['lambda']) + scale_fill_viridis() + gg(sample.p$pts)
pl2 <- ggplot() + gg(m.pixels['lambda']) + scale_fill_viridis() + gg(ss2)
pl3 <- ggplot() + gg(m.pixels['lambda']) + scale_fill_viridis() + gg(ss3)


multiplot(pl1, pl2, pl3, cols = 3)



```




```{r, eval = FALSE}
save.time.1 <- function(n.ev, Ht.loc, Sigma){
  start.t <- Sys.time()
  ss <- sample.given.loc(n.ev, Ht.loc, Sigma)
  return(as.numeric(Sys.time() - start.t))
}

save.time.2 <- function(n.ev, Ht.loc, Sigma){
  start.t <- Sys.time()
  ss <- sample.given.loc2(n.ev, Ht.loc, Sigma)
  return(as.numeric(Sys.time() - start.t))
}


times.1 <- sapply(1:1000, function(x) save.time.1(100, Ht.loc, Sigma))
times.2 <- sapply(1:1000, function(x) save.time.2(100, Ht.loc, Sigma))

rbind(summary(times.1), summary(times.2))
```

The first one is faster on the single run.
Let's try with $k$ points

```{r}
k <- 10
Ht.loc <- data.frame(long = runif(k), lat = runif(k))

plot(bdy)
points(Ht.loc)

sample.list <- lapply(1:k, function(x) sample.given.loc(1000, bdy, Ht.loc[x,], Sigma, crswgs))

sample.pts <- foreach(i = 1:k, .combine = rbind) %do% {
  SpatialPointsDataFrame(sample.list[[i]], 
                         data = data.frame(parent = rep(i, length(sample.list[[1]]))))
  
}


Ht.loc2 <- Ht.loc
coordinates(Ht.loc2) <- ~ long + lat
ggplot() + gg(bdy) +  
  geom_point(data = data.frame(sample.pts), 
             mapping = aes(x = x, y = y, color = factor(parent))) + 
  gg(Ht.loc2)


mesh.bdy <- inla.mesh.2d(boundary = bdy, max.edge = 0.02)
mesh.bdy$crs <- crswgs

loglambda <- sapply(1:mesh.bdy$n, function(x) 
  log(sum(g.s(mesh.bdy$loc[x,1:2], as.matrix(Ht.loc), Sigma)))) 


m.pixels <- pixels(mesh.bdy, nx = 100, ny = 100)
mm <- inla.mesh.projector(mesh.bdy, loc = m.pixels@coords, crs = crswgs)
mm2 <- inla.mesh.project(mm, loglambda)  
m.pixels$loglambda <- as.vector(mm2)
m.pixels$lambda <- exp(m.pixels$loglambda)

pl1 <- ggplot() + gg(m.pixels['lambda']) + gg(bdy) + scale_fill_viridis() + 
  gg(sample.pts) + gg(Ht.loc2, col = 'red')

pl2 <- ggplot() + gg(m.pixels['lambda']) + gg(bdy) + scale_fill_viridis() + gg(Ht.loc2, col = 'red')

multiplot(pl1, pl2, cols = 2)
```

# ETAS sampling

okay, now we have a function to place the events in time, a function to place them in space, a function to extract the magnitudes. We still need, a function to calculate the number of points generated by each subpoint. Here, we may have two needs: 1) a function that calculates the integral on a rectangular support. If the support is not rectangular we can split it in many little rectangles and sum up. 2) a function to calculate the integral with no space limitations. This function is less difficult to make than the previous one, but if we use it for sampling we then have to extract samples without space boundaries and then retain only the ones inside.


```{r}
# this function generates all the triggered events by a single event
# the single event
sample.triggered <- function(theta.v, beta.p, n.ev, Ht.single, Tlim, M0, bdy, crsobj){
  if(n.ev == 0){
    # initialize SpatialPointsDataFrame
    samp.points <- SpatialPoints(data.frame(x = 0, y = 0))
    samp.points <- SpatialPointsDataFrame(samp.points, data = data.frame(ts = 1, mags = 1, gen = 1))
    samp.points <- samp.points[-1,]
    proj4string(samp.points) <- crswgs
    return(samp.points)
  }
  else{
    # initialize parameters
    theta4 <- theta.v[4]
    theta5 <- theta.v[5]
    sigmax <- exp(theta.v[6])
    sigmay <- exp(theta.v[7])
    sigmaxy <- exp(theta.v[8])
    
    Sigma <- matrix(c(sigmax, sigmaxy, sigmaxy, sigmay), ncol = 2, byrow = TRUE)
    # separate info about parent
    Ht.loc <- as.numeric(Ht.single[,1:2])
    Ht.ts <- as.numeric(Ht.single[,3])
    Ht.mags <- as.numeric(Ht.single[,4])
    
    # sample times
    samp.ts <- sample.omori(n.ev, theta4, theta5, Ht.ts, Tlim)
    # sample magnitudes
    samp.mags <- rexp(n.ev, rate = beta.p) + M0
    # sample locations
    samp.locs <- sample.given.loc(n.ev, bdy, Ht.loc, Sigma, crsobj)
    
    # initialize SpatialPointsDataFrame
    #samp.points <- SpatialPoints(data.frame(x = samp.locs[, 1], y = samp.locs[,2]))
    samp.points <- SpatialPointsDataFrame(samp.locs, data = data.frame(ts = samp.ts, mags = samp.mags))
    proj4string(samp.points) <- crsobj
    samp.points <- spTransform(samp.points, crsobj)
    return(samp.points)
  }
  
}



triggered.n.ev <- function(theta.v, Ht.single, Tlim, M0, bdy){
  
  theta2 <- theta.v[2]
  theta3 <- theta.v[3]
  theta4 <- theta.v[4]
  theta5 <- theta.v[5]
  sigmax <- exp(theta.v[6])
  sigmay <- exp(theta.v[7])
  sigmaxy <- exp(theta.v[8])
    
  Sigma <- matrix(c(sigmax, sigmaxy, sigmaxy, sigmay), ncol = 2, byrow = TRUE)
  
  
  totry <- I.s(bdy@bbox[1,],bdy@bbox[2,],Sigma, cbind(Ht.single$x, Ht.single$y))
  if(is.na(totry)){
    return(exp(theta2)*exp(exp(theta3)*(as.numeric(Ht.single$mags) - M0))*
    I.t(Tlim, theta4,theta5, as.numeric(Ht.single$ts)))
  }
  else{
    return(exp(theta2)*exp(exp(theta3)*(as.numeric(Ht.single$mags) - M0))*
    I.t(Tlim, theta4,theta5, as.numeric(Ht.single$ts))*totry)
  }
}



sample.generation <- function(theta.v, beta.p, Ht, Tlim, M0, bdy, crsobj){
  n.parent <- nrow(Ht)
  # calculate rate for each point in history
  trig.rate.v <- sapply(1:n.parent, function(x) 
    triggered.n.ev(theta.v, Ht[x,], Tlim, M0, bdy))
  n.ev.v <- sapply(1:n.parent, function(x) rpois(1, trig.rate.v[x]))
  
  if(sum(n.ev.v) == 0){
    app <- SpatialPointsDataFrame(SpatialPoints(data.frame(x = 0, y = 0)), 
                             data = data.frame(ts = 1, mags = 1))
    app <- app[-1,]
    return(app)
  }
  
  sample.list <- lapply(1:n.parent, function(x) 
    sample.triggered(theta.v, beta.p, n.ev.v[x], Ht[x,], Tlim, M0, bdy, crsobj))
  sample.pts <- foreach(i = 1:n.parent, .combine = rbind) %do% {sample.list[[i]]}
  sample.pts
}

```

```{r}
#exploring the effect of the magnitude on the number of generated events.
theta.v <- log(c(1e-5, 0.09, 1.1, 1e-2, 0.1, 0.002, 0.002, 0.0019)) 

Ht <- data.frame(x = 0.5, y = 0.5, ts = 0.2, 
                 mags = seq(2.5,7,by = 0.1))

trig.rate.v <- sapply(1:nrow(Ht), function(x) 
  triggered.n.ev(theta.v, Ht[x,], 1, 2.5, bdy))

plot(Ht$mags, trig.rate.v, type = 'l')
Ht$mags[trig.rate.v < 1]
Ht$mags[trig.rate.v < 2]

Ht <- data.frame(x = 0.5, y = 0.5, ts = 0.2, 
                 mags = rexp(10000, 2.3) + M0)

trig.rate.v <- sapply(1:nrow(Ht), function(x) 
  triggered.n.ev(theta.v, Ht[x,], 1, 2.5, bdy))
 
mean(trig.rate.v)

```




```{r}
Ht <- data.frame(x = 0.5, y = 0.5, ts = 0.2, 
                 mags = 7)

# how many points it generates?
trig.rate <- triggered.n.ev(theta.v, Ht, 1, M0, bdy)
trig.rate

n.ev <- rpois(1, trig.rate)
ss <- sample.triggered(theta.v, 2.3, n.ev, Ht, 1, 2.5, bdy, crswgs)

# 
Ht2 <- data.frame(x = ss@coords[,1], y = ss@coords[,2], ts = ss$ts, mags = ss$mags, gen = 1)

flag = TRUE
gen.list <- list(Ht2)
gen = 1
while(flag){
  print(gen)
  parents <- gen.list[[gen]]
  triggered <- sample.generation(theta.v, 2.3, parents, 1, 2.5, bdy, crswgs)
  if(length(triggered) == 0){
    flag = FALSE}
  else{
    gen.list[[gen + 1]] = data.frame(x = triggered@coords[,1], 
                                   y = triggered@coords[,2], 
                                   ts = triggered$ts, 
                                   mags = triggered$mags,
                                   gen = gen + 1)
    gen = gen + 1
    }
}

ss <- bind_rows(gen.list)

ggplot() + gg(bdy) + 
  geom_point(data = ss, aes(x = x, y = y, color = factor(-gen)))

```


```{r}
sample.ETAS <- function(theta.v, beta.p, T1, T2, M0, bdy, crsobj, Ht){
  if(T2 < T1){
    stop('Error - right-end of time interval greater than left-end')
  }
  # area calculated in squared km
  n.bkg <- rpois(1, exp(theta.v[1])*(T2 - T1)*(area(bdy)/1000000))
  if(n.bkg == 0){
    print(exp(theta.v[1])*(T2 - T1)*(area(bdy)/1000000))
    stop('No events generated - increase theta1')
  }
  # sample bkg events
  bkg.locs <- spsample(bdy, n.bkg, 'random')
  proj4string(bkg.locs) <- crsobj
  bkg.locs <- spTransform(bkg.locs, crsobj)
  bkg.df <- data.frame(x = bkg.locs@coords[,1], 
                       y = bkg.locs@coords[,2], 
                       ts = runif(n.bkg, T1, T2), 
                       mags = rexp(n.bkg, beta.p) + M0, 
                       gen = 1)
  print(nrow(bkg.df))
  flag = TRUE
  Gen.list <- list(bkg.df)
  gen = 1
  while(flag){
    print(gen)
    parents <- Gen.list[[gen]]
    triggered <- sample.generation(theta.v, beta.p, parents, Tlim, M0, bdy, crsobj)
    print(length(triggered))
    if(length(triggered) == 0){
      flag = FALSE}
    else{
      Gen.list[[gen + 1]] = data.frame(x = triggered@coords[,1], 
                                     y = triggered@coords[,2], 
                                     ts = triggered$ts, 
                                     mags = triggered$mags,
                                     gen = gen + 1)
      gen = gen + 1
    }
  }
  Gen.list
}

theta.v <- log(c(1e-5, 0.09, 1.1, 1e-2, 0.1, 0.002, 0.002, 0.0019)) 
theta.v <- log(c(1e-3, 0.05, 1.1, 1e-2, 0.1, 0.002, 0.002, 0.0019)) 

ss <- sample.ETAS(theta.v, beta.p = 2.3, T1 = 0, T2 = 1, M0 = 2.5, 
                  bdy = bdy, crsobj = crswgs, Ht = NULL)

ss1 <- bind_rows(ss)
ss1$mags.class <- cut(ss1$mags, c(2.5, 3.5, 4.5, 5.5, 6.5, 9))
ggplot() + gg(bdy) + 
  geom_point(data = ss1, aes(x = x, y = y, shape = mags.class, color = factor(gen), size = mags))
```


```{r}
# italy
ss <- sample.ETAS(theta.v, beta.p = 2.3, T1 = 0, T2 = 1, M0 = 2.5, 
                  bdy = italy.contour, crsobj = crswgs, Ht = NULL)


ss1 <- bind_rows(ss)
ss1$mags.class <- cut(ss1$mags, c(2.5, 3.5, 4.5, 5.5, 6.5, 9))


ggplot() + gg(italy.contour) + 
  geom_point(data = ss1, aes(x = x, y = y))


ggplot() + gg(italy.contour) + 
  geom_point(data = ss1, aes(x = x, y = y, shape = mags.class, color = factor(gen), size = mags))


```

```{r}
# super weird behaviour
pmvnorm(lower = c(italy.contour@bbox[1,1], italy.contour@bbox[2,1]), 
        upper = c(italy.contour@bbox[1,2], italy.contour@bbox[2,2]),
        mean = c(14.5, 36.4), sigma = Sigma)

pmvnorm(lower = c(italy.contour@bbox[1,1], italy.contour@bbox[2,1]), 
        upper = c(italy.contour@bbox[1,2], italy.contour@bbox[2,2]),
        mean = c(14.4, 36.8), sigma = Sigma)
```

```{r}
# okay now lets estimate a background   
italy.horus <- read.delim('HORUS_Ita_Catalog/HORUS_Ita_Catalog.txt')

dim(italy.horus)
head(italy.horus)
# let's make it something with which we may be able to work with

library(dplyr)
italy.horus_2.5_1980 <- italy.horus %>%
  filter(Mw >= 2.5, Year >= 1980) %>%
  mutate(time.strig = paste(Year, ":", Mo, ":", Da, ":", Ho, ":", Mi, ":", Se))

italy.horus_2.5_1980$time.pos <- as.POSIXct(italy.horus_2.5_1980$time.strig,
                                            format = "%Y : %m : %d : %H : %M : %S")

head(italy.horus_2.5_1980)
names(italy.horus_2.5_1980)


italy.horus.locs <- data.frame(x = italy.horus_2.5_1980$Lon,
                               y = italy.horus_2.5_1980$Lat)
coordinates(italy.horus.locs) <- ~ x + y
proj4string(italy.horus.locs) <- crswgs
italy.horus.locs <- spTransform(italy.horus.locs, crswgs)

italy.raster <- raster(italy.grid)
counts <- table(cellFromXY(italy.raster, italy.horus.locs))
italy.raster$counts <- 0 
italy.raster$counts[as.numeric(names(counts))] <- counts

plot(italy.raster$id)

ncell(italy.raster)
length(italy.grid)
length(italy.pixels)


pl1 <- ggplot() + gg(italy.pixels)
pl2 <- ggplot() + gg(italy.grid)

multiplot(pl1, pl2, cols = 2)

raster.cell.locs <- xyFromCell(italy.raster, 1:ncell(italy.raster))

```

```{r}
save(italy.horus_2.5_1980, file = 'italy.horus_2.5_1960.RData')
```

```{r}

```
















